<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-10-25">
<meta name="description" content="This is an overview of the Optmization Algorithms. It includes the definition of the optimization algorithms, the most popular optimization algorithms like first-order optmization(e.g.&nbsp;SGD), higher-order optmization(e.g.&nbsp;Newton’s Method) algorithms. Besides, it also includes the applications of those models.">

<title>Overview: Optimization Algorithms – Yuyang’s Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Overview: Optimization Algorithms – Yuyang’s Blog">
<meta property="og:description" content="This is an overview of the Optmization Algorithms. It includes the definition of the optimization algorithms, the most popular optimization algorithms like first-order optmization(e.g.&nbsp;SGD), higher-order optmization(e.g.&nbsp;Newton’s Method) algorithms. Besides, it also includes the applications of those models.">
<meta property="og:image" content="Images/Overview_OA.png">
<meta property="og:site_name" content="Yuyang's Blog">
</head>

<body class="floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Yuyang’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/JAZ201107"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/zhang-yuyang/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="1">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#problem-formalization" id="toc-problem-formalization" class="nav-link active" data-scroll-target="#problem-formalization">Problem Formalization</a>
  <ul class="collapse">
  <li><a href="#linear-programming" id="toc-linear-programming" class="nav-link" data-scroll-target="#linear-programming">Linear Programming</a></li>
  <li><a href="#quadratic-programming" id="toc-quadratic-programming" class="nav-link" data-scroll-target="#quadratic-programming">Quadratic Programming</a></li>
  <li><a href="#semi-definition-programming" id="toc-semi-definition-programming" class="nav-link" data-scroll-target="#semi-definition-programming">Semi-Definition Programming</a></li>
  </ul></li>
  <li><a href="#first-order-optimization-methods" id="toc-first-order-optimization-methods" class="nav-link" data-scroll-target="#first-order-optimization-methods">First Order Optimization methods</a></li>
  <li><a href="#higher-order-optimization-methods" id="toc-higher-order-optimization-methods" class="nav-link" data-scroll-target="#higher-order-optimization-methods">Higher Order Optimization methods</a>
  <ul class="collapse">
  <li><a href="#conjugate-gradientcg" id="toc-conjugate-gradientcg" class="nav-link" data-scroll-target="#conjugate-gradientcg">Conjugate Gradient(CG)</a></li>
  <li><a href="#quasi-newton-methods" id="toc-quasi-newton-methods" class="nav-link" data-scroll-target="#quasi-newton-methods">Quasi-Newton Methods</a>
  <ul class="collapse">
  <li><a href="#dfp" id="toc-dfp" class="nav-link" data-scroll-target="#dfp">DFP</a></li>
  <li><a href="#bfgs" id="toc-bfgs" class="nav-link" data-scroll-target="#bfgs">BFGS</a></li>
  <li><a href="#l-bfgs" id="toc-l-bfgs" class="nav-link" data-scroll-target="#l-bfgs">L-BFGS</a></li>
  </ul></li>
  <li><a href="#hessian-free-optimization-methods" id="toc-hessian-free-optimization-methods" class="nav-link" data-scroll-target="#hessian-free-optimization-methods">Hessian-Free Optimization Methods</a></li>
  <li><a href="#natural-gradient" id="toc-natural-gradient" class="nav-link" data-scroll-target="#natural-gradient">Natural Gradient</a></li>
  <li><a href="#trust-region-method" id="toc-trust-region-method" class="nav-link" data-scroll-target="#trust-region-method">Trust Region Method</a></li>
  </ul></li>
  <li><a href="#heuristic-derivate-free-optimization-methods" id="toc-heuristic-derivate-free-optimization-methods" class="nav-link" data-scroll-target="#heuristic-derivate-free-optimization-methods">Heuristic Derivate Free Optimization methods</a></li>
  <li><a href="#preconditions" id="toc-preconditions" class="nav-link" data-scroll-target="#preconditions">Preconditions</a></li>
  <li><a href="#applications" id="toc-applications" class="nav-link" data-scroll-target="#applications">Applications</a>
  <ul class="collapse">
  <li><a href="#optimization-in-machine-learning" id="toc-optimization-in-machine-learning" class="nav-link" data-scroll-target="#optimization-in-machine-learning">Optimization in Machine Learning</a></li>
  <li><a href="#optimization-in-deep-learning" id="toc-optimization-in-deep-learning" class="nav-link" data-scroll-target="#optimization-in-deep-learning">Optimization in Deep Learning</a></li>
  <li><a href="#optimization-in-reinforcement-learning" id="toc-optimization-in-reinforcement-learning" class="nav-link" data-scroll-target="#optimization-in-reinforcement-learning">Optimization in Reinforcement Learning</a></li>
  <li><a href="#optimization-in-meta-learning" id="toc-optimization-in-meta-learning" class="nav-link" data-scroll-target="#optimization-in-meta-learning">Optimization in Meta Learning</a></li>
  <li><a href="#optimization-in-variation-inference" id="toc-optimization-in-variation-inference" class="nav-link" data-scroll-target="#optimization-in-variation-inference">Optimization in Variation Inference</a></li>
  <li><a href="#optimization-in-generative-model" id="toc-optimization-in-generative-model" class="nav-link" data-scroll-target="#optimization-in-generative-model">Optimization in Generative Model</a></li>
  <li><a href="#optimization-in-markov-chain-monte-carlo" id="toc-optimization-in-markov-chain-monte-carlo" class="nav-link" data-scroll-target="#optimization-in-markov-chain-monte-carlo">Optimization in Markov Chain Monte Carlo</a></li>
  </ul></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Overview: Optimization Algorithms</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Optmization</div>
    <div class="quarto-category">Overview</div>
  </div>
  </div>

<div>
  <div class="description">
    This is an overview of the Optmization Algorithms. It includes the definition of the optimization algorithms, the most popular optimization algorithms like first-order optmization(e.g.&nbsp;SGD), higher-order optmization(e.g.&nbsp;Newton’s Method) algorithms. Besides, it also includes the applications of those models.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2024-10-25</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Last modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">2024-10-29</p>
    </div>
  </div>
    
  </div>
  


</header>


<p>Optimization is one of the core components of machine learning and deep learning. The most part of the machine learning algorithm is to optimize the parameters in the objective function from given dataset <span class="math inline">\(\mathcal{D}\)</span>. In the era of the immense data, the effectiveness and efficiency of the <strong>numerical optimization algorithms</strong> dramatically influence the popularization and application of the machine learning.</p>
<p>Most of the optimization algorithms involve update the parameters according to the gradient information. From the perspective of the gradient information, popular optimization methods can be divided into three categories:</p>
<ul>
<li>First-Order Optimization Methods: such as stochastic gradient methods</li>
<li>Higher-Order Optimization methods: such as Newton’s method</li>
<li>Heuristic Derivative Free Optimization: such as coordinate descent method</li>
</ul>
<p>First Order Optimization methods are the most common methods used in the deep learning field, because it is easier to implement, while higher order methods converge at a faster speed with the <strong>curvature information</strong> makes the search direction more effective, is more computing demanding due to the operation and storage of the inverse matrix of the <strong>Hessian matrix</strong>. To solve this problem, many variants based on <strong>Newton’s method</strong> has been developed most of which try to <em>approximate</em> the Hessian matrix through some techniques.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong>curvature information</strong>: refers to the second-order properties of the objective landspace. Curvature describes how quickly the gradient of a function changes with respect to the model parameters.</p>
</div></div><p>Derivative free optimization methods are mainly used in the case that the derivative of the objective function may not exits or be difficult to calculate, the two main ideas are that:</p>
<ul>
<li>Adopting a heuristic search based on empirical rules</li>
<li>Fitting the objective function with samples Notes that derivative free optimization methods can work with gradient-based methods</li>
</ul>
<section id="problem-formalization" class="level1">
<h1>Problem Formalization</h1>
<section id="linear-programming" class="level2">
<h2 class="anchored" data-anchor-id="linear-programming">Linear Programming</h2>
</section>
<section id="quadratic-programming" class="level2">
<h2 class="anchored" data-anchor-id="quadratic-programming">Quadratic Programming</h2>
</section>
<section id="semi-definition-programming" class="level2">
<h2 class="anchored" data-anchor-id="semi-definition-programming">Semi-Definition Programming</h2>
</section>
</section>
<section id="first-order-optimization-methods" class="level1">
<h1>First Order Optimization methods</h1>
</section>
<section id="higher-order-optimization-methods" class="level1 page-columns page-full">
<h1>Higher Order Optimization methods</h1>
<p>The second order methods can be used for addressing the problem where an objective function is highly non-linear and ill-conditioned.</p>
<section id="conjugate-gradientcg" class="level2">
<h2 class="anchored" data-anchor-id="conjugate-gradientcg">Conjugate Gradient(CG)</h2>
<p>The conjugate gradient method is a method that only needs first-order derivative information for well-defined <strong>quadratic programming</strong>, but overcomes the shortcoming of <strong>steepest descent method</strong>, and avoids the disadvantages of Newton’s method of storing and calculating the inverse Hessian matrix.</p>
<p>It is one of the most effective methods for solving large-scale <strong>linear systems of equations</strong>. It can also be used for solving non-linear optimization equations. In the 1960s, CG method is proposed as an alternative to Gaussian elimination.</p>
<p>For a linear system: <span class="math display">\[
A\theta = b
\]</span> where <span class="math inline">\(A \in \mathbb{S}^{n \times n}_{++}\)</span> is symmetric, positive-definite matrix. The matrix <span class="math inline">\(A\)</span> and vector <span class="math inline">\(b\)</span> are known, and we want to solve the value of <span class="math inline">\(\theta\)</span>. The problem of minimize the quadratic positive definite function: <span class="math display">\[
\underset{\theta}{\min \ } F(\theta) = \frac{1}{2}\theta^{T}A\theta - b\theta + c
\]</span> can be seen as a linear system when we set the gradient of <span class="math inline">\(F(\theta^{*}) = 0\)</span>: <span class="math display">\[
\frac{d F(\theta)}{d\theta} = A\theta - b
\]</span> If <span class="math inline">\(A\)</span> is symmetric matrix.</p>
<p>The gradient of <span class="math inline">\(F(\theta)\)</span> can be obtained by simple calculation which is equals to the residual of the linear system: <span class="math display">\[
\nabla F(\theta) = r(\theta) = A\theta - b
\]</span></p>
<p>The conjugate is defined as: Given an matrix <span class="math inline">\(A \in \mathbb{S}^{n\times n}_{++}\)</span>, two non-zero vector <span class="math inline">\(d_{i}, d_{j}\)</span> are conjugate with respect to <span class="math inline">\(A\)</span> if: <span class="math display">\[
d_{i}^{T}Ad_{j} = 0
\]</span> This is also called as <span class="math inline">\(A\)</span>-orthogonality.</p>
<p>A set of non-zero vector <span class="math inline">\(\{ d_{1}, d_{2}, \dots, d_{n}\}\)</span> is said to be conjugate with respect to A if any unequal vectors are conjugate with respect to <span class="math inline">\(A\)</span>.</p>
<p>To derive the conjugate gradient method, we first initialize some random start point <span class="math inline">\(\theta_{0}\)</span> as starting point. And update the <span class="math inline">\(\theta\)</span> according to: <span class="math display">\[
\theta_{t + 1} = \theta_{t} + \eta_{t}d_{t}
\]</span> The step size <span class="math inline">\(\eta_{t}\)</span> can be obtained by a <strong>linear search</strong>, which means choose <span class="math inline">\(\eta_{t}\)</span> to minimize the objective function <span class="math inline">\(f(\cdot)\)</span> along <span class="math inline">\(\theta_{t} + \eta_{t}d_{t}\)</span>. The formula of <span class="math inline">\(\eta_{t}\)</span> is: <span class="math display">\[
\eta_{t} = \frac{r_{t}^{\intercal}r_{t}}{d^{\intercal}Ad_{t}}
\]</span></p>
<p>The search direction <span class="math inline">\(d_{t}\)</span> is obtained by a linear combination of negative residual and the previous search direction: <span class="math display">\[
d_{t} = - r_{t} +\beta_{t}d_{t-1}
\]</span> Where the <span class="math inline">\(\beta_{t}\)</span> is the update parameter, determined by: <span class="math display">\[
\beta_{t} = \frac{r_{t}^{\intercal}r_{t}}{r^{\intercal}_{t-1}r_{t-1}}
\]</span></p>
<p>One of the add property of the CG method is that to generating a new vector <span class="math inline">\(d_{t}\)</span>, we know need previous vector <span class="math inline">\(d_{t-1}\)</span></p>
<p>Check this for further illustrate : <a href="https://www.ncts.ncku.edu.tw/phys/cmr/071123/cg.pdf">An Introduction to the Conjugate Gradient Method Without the Agonizing Pain</a></p>
</section>
<section id="quasi-newton-methods" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="quasi-newton-methods">Quasi-Newton Methods</h2>
<p>The basic idea of Newton’s method is to use both the first-order derivative and second order derivative to approximate the objective function with a quadratic function, and then solve the minimum optimization of the quadratic function. The one-dimensional Newton’s iteration formula is shown as: <span class="math display">\[
\theta_{t+1}= \theta_{t} - \frac{f'(\theta_{t})}{f''(\theta_{t})}
\]</span> The high dimensional Newton’s iteration formula is: <span class="math display">\[
\theta_{t+1} = \theta_{t} - \nabla^{2}f(\theta_{t})^{-1}\nabla f(\theta_{t})
\]</span>where <span class="math inline">\(\nabla^{2} f\)</span> is <strong>Hessian</strong> matrix. The above method is called <strong>damping Newton’s method</strong>.</p>
<p>The problem of this method is computing inverse of the Hessian matrix at every iterations, which makes the storage and computation very expensive. To solve the problem we can approximate the inverse of the Hessian matrix, which is called <strong>quasi-Newton method</strong>.</p>
<p>It use positive definite matrix to approximate the inverse of the Hessian matrix. More specifically, the second-order gradient is not directly needed in this method. There are several methods to approximate the Hessian matrix and inverse matrix: ### Quasi-Newton Condition Assume the objective function <span class="math inline">\(f\)</span> can be approximated by a quadratic function, we can extend <span class="math inline">\(f(\theta)\)</span> to Taylor series at <span class="math inline">\(\theta =\theta_{t+1}\)</span>: <span class="math display">\[
f(\theta) \approx f(\theta_{t+1}) + \nabla f(\theta_{t+1})^{\intercal}(\theta - \theta_{t+1}) + \frac{1}{2}(\theta - \theta_{t+1})^{\intercal}\nabla^{2}f(\theta_{t+1})(\theta - \theta_{t+1})
\]</span></p>
<p>We can compute the gradient on both sides of the above equation and obtain: <span class="math display">\[
\nabla f(\theta) \approx \nabla f(\theta_{t+1}) + \nabla^{2}f(\theta_{t+1})(\theta - \theta_{t+!})
\]</span> Let set <span class="math inline">\(\theta = \theta_{t}\)</span>, we have: <span class="math display">\[
\nabla f(\theta_{t}) \approx \nabla f(\theta_{t+1}) + \nabla^{2}f(\theta_{t+1})(\theta_{t} - \theta_{t+1})
\]</span> We use <span class="math inline">\(B\)</span> to represent the approximate matrix of the Hessian matrix. Set <span class="math inline">\(s_{t} = \theta_{t+1} - \theta_{t}\)</span> and <span class="math inline">\(u_{t} = \nabla f(\theta_{t+1}) - \nabla f(\theta_{t})\)</span></p>
<p>The matrix <span class="math inline">\(B_{t+1}\)</span> is satisfied that: <span class="math display">\[
u_{t} = B_{t+1} s_{t}
\]</span> The above equation is called the <strong>quasi-Newton condition</strong>, or secant equation. The search direction of quasi-Newton method is: <span class="math display">\[
d_{t} = -B_{t}^{-1}g_{t}
\]</span> where <span class="math inline">\(g_{t}\)</span> is the gradient of <span class="math inline">\(f\)</span>, and the update of quasi-Newton is: <span class="math display">\[
\theta_{t+1} = \theta_{t} + \eta_{t}d_{t}
\]</span> The step size <span class="math inline">\(\eta_{t}\)</span> is chose to satisfy the <strong>Wolfe conditions.</strong></p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong>Wolfe conditions</strong>: a set of inequalities for inexact line searches <span class="math inline">\(\underset{\eta_{t}}{\min \ }f(\theta_{t} + \eta_{t} d_{t})\)</span></p>
</div></div><section id="dfp" class="level3">
<h3 class="anchored" data-anchor-id="dfp">DFP</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://noblecatt-1304922865.cos.ap-singapore.myqcloud.com/20241029005332.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
</section>
<section id="bfgs" class="level3">
<h3 class="anchored" data-anchor-id="bfgs">BFGS</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://noblecatt-1304922865.cos.ap-singapore.myqcloud.com/20241029005405.png" class="img-fluid figure-img"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
</section>
<section id="l-bfgs" class="level3">
<h3 class="anchored" data-anchor-id="l-bfgs">L-BFGS</h3>
<p>Limited memory quasi-Newton methods, named L-BFGS is an improvement based on the quasiNewton method. which is feasible in dealing with the highdimensional situation.</p>
<p>https://towardsdatascience.com/bfgs-in-a-nutshell-an-introduction-to-quasi-newton-methods-21b0e13ee504 ## Stochastic Quasi-Newton Method</p>
</section>
</section>
<section id="hessian-free-optimization-methods" class="level2">
<h2 class="anchored" data-anchor-id="hessian-free-optimization-methods">Hessian-Free Optimization Methods</h2>
</section>
<section id="natural-gradient" class="level2">
<h2 class="anchored" data-anchor-id="natural-gradient">Natural Gradient</h2>
</section>
<section id="trust-region-method" class="level2">
<h2 class="anchored" data-anchor-id="trust-region-method">Trust Region Method</h2>
</section>
</section>
<section id="heuristic-derivate-free-optimization-methods" class="level1">
<h1>Heuristic Derivate Free Optimization methods</h1>
</section>
<section id="preconditions" class="level1">
<h1>Preconditions</h1>
</section>
<section id="applications" class="level1">
<h1>Applications</h1>
<section id="optimization-in-machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-machine-learning">Optimization in Machine Learning</h2>
</section>
<section id="optimization-in-deep-learning" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-deep-learning">Optimization in Deep Learning</h2>
</section>
<section id="optimization-in-reinforcement-learning" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-reinforcement-learning">Optimization in Reinforcement Learning</h2>
</section>
<section id="optimization-in-meta-learning" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-meta-learning">Optimization in Meta Learning</h2>
</section>
<section id="optimization-in-variation-inference" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-variation-inference">Optimization in Variation Inference</h2>
</section>
<section id="optimization-in-generative-model" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-generative-model">Optimization in Generative Model</h2>
</section>
<section id="optimization-in-markov-chain-monte-carlo" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-markov-chain-monte-carlo">Optimization in Markov Chain Monte Carlo</h2>
</section>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>